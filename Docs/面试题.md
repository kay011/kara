- 描述做项目过程中遇到的问题与解决方案
- 大文件传输

## 面试题
1. 为什么要做这样一个项目
2. 介绍一下你的项目

### 线程池相关
- 线程池都有哪些组件: 
    线程集合， 任务接口: std::function<> Task; 任务队列: Queue, start()方法
- 线程池类型:
    1. newSingleThreadExecutor: 单线程化的线程池，用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFI, LIFO, 优先级)执行。
    2. newFixedThreadPool: 定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
    3. newCachedThreadPool: 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
    4. newScheduledThreadPool: 创建一个定长线程池，支持定时及周期性人物执行。
- 线程池中的几种重要的参数
    1. corePoolSize就是线程池中的核心线程数量，这几个核心线程，只是在没有用的时候，也不会回收。
    2. maximumPoolSize就是线程池中可以容纳的最大线程的数量。
    3. keepAliveTime, 就是线程池中除了核心线程之外的其他的最长可以保留的时间，因为在线程池中，处理核心线程即使在无任务的情况下也不能被清除，其余的都是有存活时间的，意思就是非核心线程可以保留的最长的空闲时间。
    4. util，就是计算这个时间的一个单位。
    5. workQueue：就是等待队列，任务可以存储在任务队列中等待被执行，执行的是FIFO原则
    6. threadFactory: 创建线程的工厂
    7. handler，是一种拒绝策略，可以在任务满了之后。拒绝执行某些任务。
- 说说线程池中拒绝策略
当请求任务不断的过来，而系统此时又处理不过来的时候，我们需要采取的策略是拒绝服务。RejectedExecutionHandler接口提供了拒绝任务处理的自定义方法的机会。在ThreadPoolExecutor中已经包含四种处理策略。
    1. AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作
    2. CallerRunsPolicy 策略：只要线程池未关闭，该策略直接在调用者线程中，运行当前的被丢弃的任务。
    3. DiscardOleddestPolicy策略： 该策略将丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。
    4. DiscardPolicy策略：该策略默默的丢弃无法处理的任务，不予任何处理。
初始化线程池时线程数的选择
如果任务是IO密集型，一般线程数需要设置2倍CPU数以上，以此来尽量利用CPU资源。
如果任务是CPU密集型，一般线程数量只需要设置CPU数加1即可，更多的线程数只能增加上下文切换，不能增加CPU利用率。
上述只是一个基本思想，如果真的需要精确的控制，还是需要上线以后观察线程池中线程数量跟队列的情况来定。    
- 五种线程池的使用场景

1. newSingleThreadExecutor：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。
2. newFixedThreadPool：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。
3. newCachedThreadPool：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。
4. newScheduledThreadPool：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。
5. newWorkStealingPool：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。

- 线程池有哪几种工作队列
1. ArrayBlockQueue: 基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序。
2. LinkedBlockingQueue: 一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool使用了这个队列。
3. SynchronousQueue: 一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
4. PriorityBlockingQueue: 一个具有优先级的无限阻塞队列。


1. 手写线程池
2. 线程的同步机制有哪些
3. 线程中的工作线程一直在等待吗？ 对, 采用固定数量线程数，里面线程运行EventLoop循环，通过注册回调来实现具体业务。
4. 你的线程池工作线程处理完一个任务后的状态是什么？ (线程的状态: 新建状态，就绪状态，阻塞状态，运行状态，死亡状态)，就绪态。

5. 如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？ (请求队列)
6. 如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略？  (超时抢占？)

- EventLoop线程池与普通线程池池的区别，锁的位置在EventLoop里

### 并发模型相关
1. 简单说一下服务器使用的并发模型
程序使用Reactor模型，并使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的来势创建固定数量的线程。使用epoll作为IO复用实现。
一般多线程服务器中的线程可分为以下几类:
- IO线程(负责网络IO)
- 计算线程(负责复杂计算)
- 第三方库所用线程
本程序中的Log线程属于第三种，其它线程属于IO线程，因为Web静态服务器计算量较小，所以没有分配计算线程，减少跨线程分配的开销，让IO线程兼顾计算任务。除Log线程外，每个线程一个事件循环，遵循One loop per thread。


2. Reactor， Proactor，主从reactor模型的区别
3. SELECT, POLL, EPOLL区别， EPOLL ET与LT

### HTTP
1. 状态机
2. 画一下状态机的转移图
3. HTTP与HTTPS
4. HTTPS 的ssl的连接过程
5. GET和POST的区别

### 定时器相关
1. 为什么要使用定时器
2. 说一下定时器的工作原理
3. 双向链表，删除和添加的时间复杂度
4. 最小堆，说一下时间复杂度和工作原理

### 日志相关
1. 说一下日志系统的运行机制
2. 为什么要使用异步，和同步的区别。讲一下双缓冲与BlockQueue的区别
3. 现在你要监控一台服务器的状态，输出监控日志，请问如何将该日志分发到不同的机器上？（消息队列）

### 压测相关
1. 服务器并发量测试过吗，怎么测试的
2. webbench是什么，介绍一下原理
3. 测试的时候有没有遇到问题


### 其他
你的服务器相比于其他的服务器有什么亮点
前端发送请求后，服务器处理的过程，中间涉及哪些协议？